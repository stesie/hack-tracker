#! /bin/bash

if [ \! -e "$1" ]; then
	echo "shot-scraper: File does not exist: $1" 1>&2
	exit 2
fi

filename="$1"; shift;

debug() {
	true
}

log() {
	message="$1"; shift;
	echo "$filename: $message" 1>&2
}

error() {
	message="$1"; shift;
	echo "$filename: $message" 1>&2

	if [ "$tempFile" != "" ]; then
		rm -f "$tempFile" "$tempFile.txt"
	fi

	exit 2
}

set -- `identify -format "%w %h" "$filename"`
imgWidth="$1"; shift;
imgHeight="$1"; shift;
debug "detected image size: $imgWidth x $imgHeight pixels"

case "$imgWidth"x"$imgHeight" in
	768x1280 )
		# "Items acquired" string is positioned dynamically, if just one item
		# is acquired, then it is roughly at 578x80+96+486.
		# If three items are acquired, it's about 578x80+96+402
		resultsLeft=$[$imgWidth * 12 / 100]
		resultsWidth=$[$imgWidth * 75 / 100]
		resultsHeadTop=530
		resultsHeadTopOffset=89
		resultsHeadHeight=$[$imgHeight * 6 / 100]

		# list of acquired items starts on line below resultsHeadTop, expanding down to 950
		resultsListBottom=$[$imgHeight * 75 / 100]

		# energy string
		energyWidth=$[$imgWidth * 25 / 100]
		energyHeight=$[$imgHeight * 4 / 100]
		energyLeft=$[$imgWidth * 57 / 100]
		energyTop=$[$imgHeight * 12 / 100]

		# reso list positions
		resoListWidth=$[$imgWidth * 8 / 100]
		resoListHeight=$[$imgHeight * 3 / 100]

		resoListLeft=$[$imgWidth * 12 / 100]
		resoListOffset=$[$imgWidth * 8 / 100]
		resoListTop=$[$imgHeight * 51 / 100]
		resoListTop2=$[$imgHeight * 69 / 100]

		portalLevelLeft=684
		portalLevelTop=64
		portalLevelWidth=70
		portalLevelHeight=58
		;;

	800x1280 )
		# "Items acquired" string is positioned dynamically, if just one item
		# is acquired, then it is roughly at 578x80+96+486.
		# If three items are acquired, it's about 578x80+96+402
		resultsLeft=94
		resultsWidth=616
		resultsHeadTop=511
		resultsHeadTopOffset=73
		resultsHeadHeight=62

		# list of acquired items starts on line below resultsHeadTop, expanding down to 950
		resultsListBottom=972

		# energy string
		energyWidth=89
		energyHeight=33
		energyLeft=467
		energyTop=115

		# reso list positions
		resoListWidth=35
		resoListHeight=28

		resoListLeft=148
		resoListOffset=46
		resoListTop=771
		resoListTop2=949

		portalLevelLeft=734
		portalLevelTop=51
		portalLevelWidth=58
		portalLevelHeight=40
		;;

	480x800 )
		resultsLeft=64
		resultsWidth=348
		resultsHeadTop=318
		resultsHeadTopOffset=75
		resultsHeadHeight=60
		resultsListBottom=633

		# energy string
		energyWidth=84
		energyHeight=30
		energyLeft=283
		energyTop=119

		# reso list positions
		resoListWidth=43
		resoListHeight=27

		resoListLeft=51
		resoListOffset=47
		resoListTop=405
		resoListTop2=582

		portalLevelLeft=407
		portalLevelTop=57
		portalLevelWidth=52
		portalLevelHeight=38
		;;

	*)
		error "unsupported image resolution: $imgWidth x $imgHeight pixels"
		break;;
esac

tempFile="`mktemp`.jpg"
debug "using temporary file $tempFile"

convertOpts="-quality 100%"

# Remove dark background stuff
convertOpts="$convertOpts -contrast"
convertOpts="$convertOpts -fill black -fuzz 45% -opaque black"

# Remove turquois resonator lines
convertOpts="$convertOpts -fill black -fuzz 10% -opaque rgb(25,121,181) -strip "

#convertOpts="$convertOpts -sharpen 0x1.0"
convertOpts="$convertOpts -contrast"

emptyOpts="-fuzz 3% -transparent rgb(16,31,34) -transparent rgb(8,20,16) -transparent rgb(25,105,156) -trim"


#
# handle "portal info" page
# we handle it first, since "items acquired" requires some scanning, making it more expensive
#
convert "$filename" -crop "$energyWidth"x"$energyHeight"+$energyLeft+$energyTop "$tempFile"
#eog "$tempFile"
tesseract "$tempFile" "$tempFile" -psm 7 > /dev/null

getReso() {
	offsetX=$1; shift;
	offsetY=$1; shift;

	convert "$filename" -crop "$resoListWidth"x"$resoListHeight"+$offsetX+$offsetY $emptyOpts "$tempFile" 2>/dev/null
	set -- `identify -format "%w %h" "$tempFile"`

	if [ "$1" -lt "5" -o "$2" -lt "5" ]; then
		log "empty resonator slot found"
		resoList="0 $resoList"
		return
	fi

	convert "$filename" -crop "$resoListWidth"x"$resoListHeight"+$offsetX+$offsetY $convertOpts "$tempFile"
	tesseract "$tempFile" "$tempFile" -psm 7 ingress > /dev/null || return 0
	#cat "$tempFile.txt"; eog "$tempFile"

	level=`perl -ne 'if(m/^L([1-8])/) { print $1 }' < "$tempFile.txt"`
	[ "$level" = "" ] && {
		#eog "$tempFile"
		error "resonator level not readable"
	}

	resoList="$level $resoList"
	resoTotal=$[$resoTotal + $level]
}

if grep -qe "Energy" "$tempFile.txt"; then
	debug "detected 'portal info' page"
	resoList=""
	resoTotal=0

	for offset in 0 1 2 3; do
		getReso $[$resoListLeft + $resoListOffset * $offset] $resoListTop
		getReso $[$resoListLeft + $resoListOffset * $offset] $resoListTop2
	done

	convert "$filename" -crop "$portalLevelWidth"x"$portalLevelHeight"+$portalLevelLeft+$portalLevelTop $convertOpts "$tempFile"
	tesseract "$tempFile" "$tempFile" -psm 7 ingress > /dev/null || return 0
	#cat "$tempFile.txt"; eog "$tempFile"

	level=`perl -ne 'if(m/^L([1-8])/) { print $1 }' < "$tempFile.txt"`
	[ "$level" = "" ] && {
		#eog "$tempFile"
		error "portal level not readable"
	}

	if [ $resoTotal -eq 0 ]; then
		expectPortalLevel=1
	else
		expectPortalLevel=$[$resoTotal / 8]
	fi

	#echo $resoTotal
	#echo $expectPortalLevel
	#echo $level

	if [ $level -ne $expectPortalLevel ]; then
		error "calculated portal level mismatches actual portal level"
	fi

	set -- $resoList
	echo -n "[ $1"; shift

	for level in $*; do
		echo -n ", $1"; shift
	done
	echo "]"

	rm -f "$tempFile" "$tempFile.txt"
	exit 0
fi



#
# handle "items acquired" page
#
convertOpts="-quality 100%"

# Remove red stuff from the right half of the screen (i.e. stuff like -3%)
convertOpts="$convertOpts ( +clone -crop "$[$imgWidth / 2]"x$imgHeight+"$[$imgWidth / 2]"+0  -fill black -fuzz 45% -opaque red ) -layers flatten"

# Remove dark background stuff
convertOpts="$convertOpts -contrast"
convertOpts="$convertOpts -fill black -fuzz 45% -opaque black"
convertOpts="$convertOpts -contrast"

scrapeResults() {
	first=1
	echo -n "{ \"type\": \"$1\", \"items\": ["

	while [ $[$resultsListTop + $resultsHeadHeight] -lt $resultsListBottom ]; do
		resultsListTop=$[$resultsListTop + $resultsHeadTopOffset]
		resultsListHeight=$[$resultsListBottom - $resultsListTop]

		convert "$filename" $convertOpts -crop "$resultsWidth"x"$resultsHeadHeight"+$resultsLeft+$resultsListTop "$tempFile"
		tesseract "$tempFile" "$tempFile" ingress-items > /dev/null
		sed -i -e 's/°\/0/%/'  -e 's/°\/c/%/'  -e 's/-[0-9]%//' "$tempFile.txt"
		read a b c d < "$tempFile.txt"
		#cat "$tempFile.txt"; eog "$tempFile"

		if [ "$a" = "" ]; then
			break
		fi

		if [ "$a" = "LI" -o "$a" = "Ll" ]; then
			a="L1"
		fi

		if grep -qe "OPEN" -e "Report" -- "$tempFile.txt"; then
			object="Media"
			level=0
			quantity=1
		else
			object=$b

			test "$b" = "Key" && a=Portal
			test "$b" = "Shield" && a=Portal

			case $a in
			L1 | L2 | L3 | L4 | L5 | L6 | L7 | L8)
				if [ "$b" = "Resonator" ]; then
					quantity=$c
				elif [ "$b" = "Xmp" ]; then
					quantity=$d
				elif [ "$b" = "Power" ]; then
					quantity=$d
					object="Cube"
				else
					error "parse error, unknown b=$b"
				fi

				level=${a#L}
				;;

			Portal)
				quantity=$c
				level=0
				;;

			*)
				error "parse error, unknown a=$a b=$b"
				;;
			esac

			if [ "$quantity" = "" ]; then
				quantity=1
			else
				quantity="`perl -e '$_ = shift @ARGV;
					if(m/\((\d)\)/) { print $1 } else { print 0 }' -- "$quantity"`"
				if [ $quantity -eq 0 ]; then
					error "failed to parse quantity=$quantity"
				fi
			fi
		fi

		if [ $first -ne 1 ]; then
			echo -n ", "
		else
			first=0
		fi

		echo -n "{ \"object\": \"$object\", \"level\": ${level#L}, \"quantity\": $quantity }"
	done

	echo "]}";

	rm -f "$tempFile" "$tempFile.txt"
	exit 0
}

for offset in `seq 0 9`; do
	resultsListTop=$[$resultsHeadTop - $resultsHeadTopOffset * $offset / 2]
	convert "$filename" $convertOpts -crop "$resultsWidth"x"$resultsHeadHeight"+$resultsLeft+$resultsListTop "$tempFile"
	tesseract "$tempFile" "$tempFile" > /dev/null
	#cat "$tempFile.txt"; eog "$tempFile"

	if grep -qe "Items acquired" "$tempFile.txt"; then
		debug "detected 'items acquired' page at offset $offset"
		scrapeResults "friendly"
	elif grep -qe "Hack successful" "$tempFile.txt"; then
		debug "detected 'hack successful' page at offset $offset"
		scrapeResults "enemy"
	elif grep -qe "Hack acqu" "$tempFile.txt"; then		# only short phrase, since red -x% likely at the right hand side
		debug "hack failed"
		echo -n "{ \"type\": \"enemy\", \"items\": [] }"
		rm -f "$tempFile" "$tempFile.txt"
		exit 0
	elif grep -qe "Portal running hot" "$tempFile.txt"; then
		debug "Portal running hot"
		rm -f "$tempFile" "$tempFile.txt"
		exit 0
	fi
done


rm -f "$tempFile" "$tempFile.txt"
error "unsupported page type"
ln $filename unsupported/
